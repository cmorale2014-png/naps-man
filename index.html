<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Naps-Man</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            background-color: #111;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
        }

        canvas {
            background-color: #000;
            border: 4px solid #2244CC;
            box-shadow: 0 0 20px rgba(34, 68, 204, 0.4);
            max-width: 100%;
            max-height: 80vh;
        }

        #ui-layer {
            width: 100%;
            max-width: 600px;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            box-sizing: border-box;
            font-size: 14px;
            text-transform: uppercase;
        }

        .score-label { color: #FFB8AE; }
        .score-val { color: #FFF; }

        #message-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            text-align: center;
        }

        .hidden { display: none !important; }

        button {
            background: #FFCC00;
            color: #000;
            border: none;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
        }
        button:hover { background: #FFF; }
        
        button:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        #loading-text {
            color: #4ade80;
            font-size: 12px;
            margin-top: 20px;
            min-height: 20px;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="ui-layer">
        <div>Score: <span id="score" class="score-val">0</span></div>
        <div style="color: #FF0000">HIGH: <span id="highscore" class="score-val">0</span></div>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <div id="message-overlay">
        <h1 id="title-text" style="color: #FFCC00; text-shadow: 4px 4px #d35400; font-size: 40px; margin-bottom: 20px;">NAPS-MAN</h1>
        <p id="sub-text" style="line-height: 1.5; margin-bottom: 10px; color: #ccc;">Eat all dots.<br>Avoid Uncle Marcs.</p>
        
        <div id="loading-text">LOADING ASSETS...</div>
        <button id="start-btn" disabled>LOADING...</button>
    </div>
</div>

<script>
    /**
     * NAPS-MAN GAME ENGINE - GITHUB HOSTED VERSION
     * Assets are loaded from the assets/ folder
     */

    // --- Configuration ---
    const TILE_COUNT_X = 19;
    const TILE_COUNT_Y = 20; 
    let TILE_SIZE = 24; 
    
    // Speeds
    const PACMAN_SPEED = 0.11; 
    const GHOST_SPEED = 0.09; 
    
    const ANIMATION_RATE_HZ = 2; 
    const ANIMATION_INTERVAL_MS = 1000 / (ANIMATION_RATE_HZ * 2);

    // --- Assets Management ---
    // UPDATED to match your latest folder structure and capitalization
    const ASSET_PATHS = {
        playerOpen: 'assets/face_open.JPG',     // Capital JPG
        playerClosed: 'assets/face_closed.jpg', // Lowercase jpg
        ghost: 'assets/ghost.PNG',              // Capital PNG
        music: 'assets/music.mp3'               // Lowercase mp3
    };

    const imgOpen = new Image();
    const imgClosed = new Image();
    const imgGhost = new Image(); 
    const bgMusic = new Audio();
    bgMusic.loop = true;

    let loadedCount = 0;
    const totalAssets = 4;
    
    function assetLoaded() {
        loadedCount++;
        const btn = document.getElementById('start-btn');
        const loadText = document.getElementById('loading-text');
        
        if (loadedCount >= totalAssets) {
            btn.disabled = false;
            btn.innerText = "INSERT COIN";
            loadText.innerText = "SYSTEM READY";
            loadText.style.color = "#4ade80"; // Green
        } else {
            loadText.innerText = `LOADING... ${Math.floor((loadedCount/totalAssets)*100)}%`;
            loadText.style.color = "#ffff00"; // Yellow
        }
    }

    function assetError(e) {
        const loadText = document.getElementById('loading-text');
        loadText.innerText = "ERROR LOADING ASSETS";
        loadText.style.color = "red";
        console.error("Failed to load asset:", e.target.src);
        
        // Helpful debug info for you
        const fileName = e.target.src.split('/').pop();
        alert("Could not load: " + fileName + "\nCheck folder structure and capitalization!");
    }

    // Trigger Loads
    imgOpen.onload = assetLoaded; imgOpen.onerror = assetError;
    imgOpen.src = ASSET_PATHS.playerOpen;

    imgClosed.onload = assetLoaded; imgClosed.onerror = assetError;
    imgClosed.src = ASSET_PATHS.playerClosed;

    imgGhost.onload = assetLoaded; imgGhost.onerror = assetError;
    imgGhost.src = ASSET_PATHS.ghost;

    bgMusic.oncanplaythrough = assetLoaded; 
    bgMusic.onerror = assetError;
    bgMusic.src = ASSET_PATHS.music;
    
    // --- Game State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameRunning = false;
    let score = 0;
    let highScore = localStorage.getItem('napsman_highscore') || 0;
    document.getElementById('highscore').innerText = highScore;

    // 0: Wall, 1: Dot, 2: Empty, 3: Power, 4: Gate
    const mapLayout = [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0],
        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0],
        [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
        [0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0],
        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0],
        [0,0,0,0,1,0,0,0,2,0,2,0,0,0,1,0,0,0,0],
        [2,2,2,0,1,0,2,2,2,2,2,2,2,0,1,0,2,2,2],
        [0,0,0,0,1,0,2,0,0,4,0,0,2,0,1,0,0,0,0],
        [2,2,2,2,1,2,2,0,2,2,2,0,2,2,1,2,2,2,2],
        [0,0,0,0,1,0,2,0,0,0,0,0,2,0,1,0,0,0,0],
        [2,2,2,0,1,0,2,2,2,2,2,2,2,0,1,0,2,2,2],
        [0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0],
        [0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0],
        [0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0],
        [0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0],
        [0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0],
        [0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
    ];

    let grid = []; 

    // --- Classes ---

    class Entity {
        constructor(x, y) {
            this.x = x; 
            this.y = y;
            this.dir = {x: 0, y: 0}; 
            this.nextDir = {x: 0, y: 0}; 
            this.speed = 0.1;
            this.radius = 0.4;
        }

        canMoveTo(tx, ty) {
            if (tx < 0 || tx >= TILE_COUNT_X || ty < 0 || ty >= TILE_COUNT_Y) return false;
            const tile = grid[ty][tx];
            return tile !== 0 && tile !== 4; 
        }
    }

    class Pacman extends Entity {
        constructor(x, y) {
            super(x, y);
            this.speed = PACMAN_SPEED;
            this.angle = 0;
            this.lastImageSwitch = 0;
            this.isMouthOpen = false;
        }

        update(dt) {
            const cx = Math.floor(this.x) + 0.5;
            const cy = Math.floor(this.y) + 0.5;
            const dist = Math.sqrt((this.x - cx)**2 + (this.y - cy)**2);
            
            if (dist < this.speed) {
                if ((this.nextDir.x !== 0 || this.nextDir.y !== 0)) {
                     const nextTx = Math.floor(this.x) + this.nextDir.x;
                     const nextTy = Math.floor(this.y) + this.nextDir.y;
                     
                     if (this.canMoveTo(nextTx, nextTy)) {
                        this.x = cx;
                        this.y = cy;
                        this.dir = { ...this.nextDir };
                        this.nextDir = {x: 0, y: 0};
                     }
                }
                
                const nextTx = Math.floor(this.x) + this.dir.x;
                const nextTy = Math.floor(this.y) + this.dir.y;
                
                if (!this.canMoveTo(nextTx, nextTy)) {
                    this.x = cx;
                    this.y = cy;
                    this.dir = {x: 0, y: 0};
                }
            }

            this.x += this.dir.x * this.speed;
            this.y += this.dir.y * this.speed;

            if (this.x < 0) this.x = TILE_COUNT_X - 1;
            if (this.x >= TILE_COUNT_X) this.x = 0;

            if (this.dir.x === 1) this.angle = 0;
            if (this.dir.x === -1) this.angle = Math.PI;
            if (this.dir.y === -1) this.angle = -Math.PI / 2;
            if (this.dir.y === 1) this.angle = Math.PI / 2;

            const tx = Math.floor(this.x); 
            const ty = Math.floor(this.y);
            
            if(ty >= 0 && ty < TILE_COUNT_Y && tx >= 0 && tx < TILE_COUNT_X) {
                const cxDot = tx + 0.5;
                const cyDot = ty + 0.5;
                const d = Math.sqrt((this.x - cxDot)**2 + (this.y - cyDot)**2);
                
                if (d < 0.4 && grid[ty][tx] === 1) {
                    grid[ty][tx] = 2; 
                    score += 10;
                    document.getElementById('score').innerText = score;
                    checkWin();
                }
            }

            const now = Date.now();
            if (now - this.lastImageSwitch > ANIMATION_INTERVAL_MS) {
                this.isMouthOpen = !this.isMouthOpen;
                this.lastImageSwitch = now;
            }
        }

        draw(ctx) {
            const px = this.x * TILE_SIZE; 
            const py = this.y * TILE_SIZE;

            ctx.save();
            ctx.translate(px, py); 
            ctx.rotate(this.angle);

            const size = TILE_SIZE * 1.6; 
            
            // Draw Custom Asset
            const img = this.isMouthOpen ? imgOpen : imgClosed;
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 2, 0, Math.PI * 2);
            ctx.clip(); 
            ctx.drawImage(img, -size/2, -size/2, size, size);
            
            ctx.restore();
        }
    }

    class Ghost extends Entity {
        constructor(x, y, color, startDir) {
            const cx = Math.floor(x) + 0.5;
            const cy = Math.floor(y) + 0.5;
            super(cx, cy);
            this.color = color;
            this.speed = GHOST_SPEED;
            this.dir = startDir || {x: 1, y: 0};
            this._decisionCooldown = 0; 
        }

        canMoveTo(tx, ty) {
            if (tx < 0 || tx >= TILE_COUNT_X || ty < 0 || ty >= TILE_COUNT_Y) return false;
            const tile = grid[ty][tx];
            return tile !== 0; 
        }

        move() {
            const centerX = Math.floor(this.x) + 0.5;
            const centerY = Math.floor(this.y) + 0.5;
            const dist = Math.sqrt((this.x - centerX)**2 + (this.y - centerY)**2);
            const SNAP_THRESHOLD = Math.max(0.06, this.speed * 0.5);

            if (this._decisionCooldown > 0) this._decisionCooldown--;

            if (dist < SNAP_THRESHOLD && this._decisionCooldown === 0) {
                this.x = centerX;
                this.y = centerY;

                const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                const txBase = Math.floor(this.x);
                const tyBase = Math.floor(this.y);

                const validDirs = dirs.filter(d => this.canMoveTo(txBase + d.x, tyBase + d.y));

                if (validDirs.length > 0) {
                    const nonReverse = validDirs.filter(d => !(d.x === -this.dir.x && d.y === -this.dir.y));
                    if (nonReverse.length > 0) {
                        this.dir = nonReverse[Math.floor(Math.random() * nonReverse.length)];
                    } else {
                        this.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
                    }
                    this._decisionCooldown = 6; 
                } else {
                    this._decisionCooldown = 6;
                }
            }

            this.x += this.dir.x * this.speed;
            this.y += this.dir.y * this.speed;

            if (this.x < 0) this.x = TILE_COUNT_X - 1;
            if (this.x >= TILE_COUNT_X) this.x = 0;
        }

        draw(ctx) {
            const px = this.x * TILE_SIZE; 
            const py = this.y * TILE_SIZE;
            
            // DRAW CUSTOM GHOST IMAGE
            const size = TILE_SIZE * 1.5; // Slightly larger for face
            ctx.save();
            ctx.translate(px, py);
            
            // Draw Colored Ring
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, Math.PI * 2);
            ctx.lineWidth = 3;
            ctx.strokeStyle = this.color;
            ctx.stroke();
            
            // Clip for image
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 1, 0, Math.PI * 2);
            ctx.clip();
            
            ctx.drawImage(imgGhost, -size/2, -size/2, size, size);
            ctx.restore();
        }
    }

    // --- Instantiation ---
    let pacman;
    let ghosts = [];

    function initGame() {
        grid = mapLayout.map(row => [...row]);
        score = 0;
        document.getElementById('score').innerText = score;

        pacman = new Pacman(9.5, 16.5); 
        
        ghosts = [
            new Ghost(1, 1, "red", {x:1, y:0}),     // Top Left
            new Ghost(17, 1, "pink", {x:-1, y:0}),  // Top Right
            new Ghost(1, 18, "cyan", {x:1, y:0}),   // Bottom Left
            new Ghost(17, 18, "orange", {x:-1, y:0}) // Bottom Right
        ];

        resize();
    }

    function checkWin() {
        let dots = 0;
        for(let row of grid) {
            for(let tile of row) {
                if(tile === 1) dots++;
            }
        }
        if(dots === 0) {
            gameOver("YOU WIN!");
        }
    }

    function gameOver(msg) {
        gameRunning = false;
        
        // Stop Music
        bgMusic.pause();
        bgMusic.currentTime = 0;

        if(score > highScore) {
            highScore = score;
            localStorage.setItem('napsman_highscore', highScore);
            document.getElementById('highscore').innerText = highScore;
        }
        document.getElementById('title-text').innerText = msg;
        document.getElementById('sub-text').innerText = `Final Score: ${score}`;
        document.getElementById('start-btn').innerText = "PLAY AGAIN";
        document.getElementById('message-overlay').classList.remove('hidden');
    }

    function loop() {
        if (!gameRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Update
        if (pacman) pacman.update();
        if (ghosts) ghosts.forEach(g => {
            g.move();
            const dx = g.x - pacman.x;
            const dy = g.y - pacman.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if(dist < 0.6) {
                gameOver("GAME OVER");
            }
        });

        // Draw Map
        const renderRows = Math.min(TILE_COUNT_Y, grid.length);
        
        for (let y = 0; y < renderRows; y++) {
            for (let x = 0; x < TILE_COUNT_X; x++) {
                const tile = grid[y][x];
                const px = x * TILE_SIZE;
                const py = y * TILE_SIZE;

                if (tile === 0) {
                    ctx.fillStyle = "#1919A6"; 
                    ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = "black"; 
                    ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                } else if (tile === 1) {
                    ctx.fillStyle = "#ffb8ae";
                    ctx.fillRect(px + TILE_SIZE/2 - 2, py + TILE_SIZE/2 - 2, 4, 4);
                } else if (tile === 4) {
                    ctx.fillStyle = "pink";
                    ctx.fillRect(px, py + TILE_SIZE/2 - 2, TILE_SIZE, 4);
                }
            }
        }

        // Draw Entities
        if (pacman) pacman.draw(ctx);
        if (ghosts) ghosts.forEach(g => g.draw(ctx));

        requestAnimationFrame(loop);
    }

    // --- Input & Resize ---

    function handleInput(key) {
        if(!gameRunning || !pacman) return;
        switch(key) {
            case 'ArrowUp': case 'w': pacman.nextDir = {x: 0, y: -1}; break;
            case 'ArrowDown': case 's': pacman.nextDir = {x: 0, y: 1}; break;
            case 'ArrowLeft': case 'a': pacman.nextDir = {x: -1, y: 0}; break;
            case 'ArrowRight': case 'd': pacman.nextDir = {x: 1, y: 0}; break;
        }
    }

    window.addEventListener('keydown', e => handleInput(e.key));

    // Touch Handling
    let touchStartX = 0;
    let touchStartY = 0;
    
    document.addEventListener('touchstart', e => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
    }, {passive: false});

    document.addEventListener('touchmove', e => {
        if(gameRunning) e.preventDefault(); 
    }, {passive: false});

    document.addEventListener('touchend', e => {
        if(!gameRunning) return;
        const dx = e.changedTouches[0].clientX - touchStartX;
        const dy = e.changedTouches[0].clientY - touchStartY;
        
        if(Math.abs(dx) > Math.abs(dy)) {
            if(Math.abs(dx) > 30) handleInput(dx > 0 ? 'ArrowRight' : 'ArrowLeft');
        } else {
            if(Math.abs(dy) > 30) handleInput(dy > 0 ? 'ArrowDown' : 'ArrowUp');
        }
    });

    function resize() {
        const aspect = TILE_COUNT_X / TILE_COUNT_Y;
        const maxW = window.innerWidth - 20;
        const maxH = window.innerHeight - 100; 
        
        let w = maxW;
        let h = w / aspect;

        if (h > maxH) {
            h = maxH;
            w = h * aspect;
        }

        canvas.width = w;
        canvas.height = h;
        
        TILE_SIZE = w / TILE_COUNT_X;

        if(!gameRunning) {
             ctx.fillStyle = "black";
             ctx.fillRect(0,0,canvas.width, canvas.height);
        }
    }

    window.addEventListener('resize', resize);

    document.getElementById('start-btn').addEventListener('click', () => {
        document.getElementById('message-overlay').classList.add('hidden');
        initGame();
        gameRunning = true;
        
        // Start Audio
        bgMusic.play().catch(e => console.log("Audio Error:", e));

        loop();
    });

    resize();

</script>
</body>
</html>